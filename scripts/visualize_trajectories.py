import torch
import numpy as np
from tqdm import tqdm

from os import path

from mg_diffuse import utils

package_name = 'mg_diffuse'
path_prefix = 'diffusion'

dataset = 'pendulum_lqr_5k'
exp_name = 'defaults_H32_T20'

model_state_name = 'state_800000.pt'


def load_args(logs_path):
    args_path = path.join(logs_path, 'args.json')
    return utils.JSONArgs(args_path)


def load_model(args, logs_path):
    model_path = path.join(logs_path, model_state_name)

    print(f'[ scripts/visualize_trajectories ] Loading model from {model_path}')


    model_state_dict = torch.load(model_path, weights_only=False)
    diff_model_state = model_state_dict['model']

    model_class = utils.import_class(args.model)
    diffusion_class = utils.import_class(args.diffusion)

    model = model_class(
        horizon=args.horizon,
        transition_dim=args.observation_dim,
        cond_dim=args.observation_dim,
        dim_mults=args.dim_mults,
        attention=args.attention,
    ).to(args.device)

    diffusion = diffusion_class(
        model=model,
        horizon=args.horizon,
        observation_dim=args.observation_dim,
        n_timesteps=args.n_diffusion_steps,
        loss_type=args.loss_type,
        clip_denoised=args.clip_denoised,
        predict_epsilon=args.predict_epsilon,
        ## loss weighting
        loss_weights=args.loss_weights,
        loss_discount=args.loss_discount,
    ).to(args.device)

    # Load model state dict
    diffusion.load_state_dict(diff_model_state)

    return diffusion

def generate_trajectories(model, args, start_states, only_execute_next_step=False):
    """
    Generate a trajectory from the model given the start states.
    
    Args:
        model: The model to generate the trajectory from.
        args: The arguments used to generate the model.
        start_states: The initial states to start the trajectory from.
            batch_size x observation_dim
        only_execute_next_step: If True, only execute the next step of the trajectory. (like MPC)
    """

    print('[ scripts/visualize_trajectories ] Generating trajectories')

    max_path_length = args.max_path_length
    batch_size = len(start_states)

    current_states = torch.tensor(start_states, dtype=torch.float32).to(args.device)
    current_idx = 1
    next_path_lengths = args.horizon - 1 if not only_execute_next_step else 1

    trajectories = np.zeros((batch_size, max_path_length, args.observation_dim))
    trajectories[:, 0] = np.array(start_states)

    with tqdm(total=max_path_length) as pbar:
        while current_idx < max_path_length:
            conditions = {0: current_states}

            #Forward pass to get the next states
            next_trajs = model.forward(conditions, horizon=args.horizon, verbose=False).trajectories

            # Check what is the size of trajectory required to reach max_path_length
            slice_path_length = min(next_path_lengths, max_path_length - current_idx)

            #Removing the start state and taking only the required path lengths
            next_trajs = next_trajs[:, 1:1+slice_path_length]

            #Adding the next states to the trajectory
            trajectories[:, current_idx:current_idx+slice_path_length] = next_trajs.cpu().numpy()

            current_states = next_trajs[:, -1]
            current_idx += next_path_lengths

            pbar.update(slice_path_length)

    return trajectories


def visualize_trajectories(trajectories, logs_path):
    """
    Visualize the trajectories generated by the model.
    """

    print('[ scripts/visualize_trajectories ] Visualizing trajectories...')

    import matplotlib.pyplot as plt

    for i in range(trajectories.shape[0]):
        plt.plot(trajectories[i, :, 0], trajectories[i, :, 1])


    image_path = path.join(logs_path, 'trajectories.png')

    plt.savefig(image_path)

    print(f'[ scripts/visualize_trajectories ] Trajectories saved at {image_path}')


def main():
    logs_path = path.join('logs', dataset, path_prefix, exp_name)
    args = load_args(logs_path)

    model = load_model(args, logs_path)

    start_states = []

    # Generate a grid of states with a gap of 0.1
    for theta in np.arange(-np.pi, np.pi, 0.1):
        for omega in np.arange(-2 * np.pi, 2 * np.pi, 0.1):
            start_states.append([theta, omega])

    start_states = np.array(start_states)

    trajectories = generate_trajectories(model, args, start_states, only_execute_next_step=True)

    visualize_trajectories(trajectories, logs_path)

if __name__ == '__main__':
    main()
